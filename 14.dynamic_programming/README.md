# 动态规划

## 关键点

- 动态规划 和 递归 或者 分治 没有根本上的区别（关键看有无最优的子结构）
- **共性：找到重复子问题**
- 差异性：最优子结构、中途可以**淘汰**次优解。三步走：
    1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)
    2. 储存中间状态：opt[i]
    3. 递推公式（美其名曰：状态转移方程 或 DP 方程）
        - Fib：opt[i] = opt[i-1] + opt[i-2]
        - 二维路径：opt[i, j] = opt[i+1, j] + opt[i, j+1]（且判断 opt[i, j]是否为空地）

## 斐波那契数列（一维数组）

递推公式：
```
F(n) = F(n-1) + F(n-2)
```

1. 记忆化搜索（memozation）：加缓存，自顶向下
2. 自底向上：递推（for 循环，所以又叫动态递推），eg: 0，1，1，2，3，5，8，13，……

## 路径计数

可以转换思路，变为自底向上，从右下开始往左上走。

递推公式：（opt = optimal）
```
opt[i, j] = opt[i+1, j] + opt[i, j+1]
```

完整逻辑：
```
if a[i, j] = '空地':
    opt[i, j] = opt[i+1, j] + opt[i, j+1]
else:
    opt[i, j] = 0   // 遇到障碍物，走法为 0
```
